{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#useinsertioneffect\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect(setup, dependencies?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#injecting-dynamic-styles-from-css-in-js-libraries\",\"depth\":3,\"text\":\"从 CSS-in-JS 库中注入动态样式 \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 是为 CSS-in-JS 库的作者特意打造的。除非你正在使用 CSS-in-JS 库并且需要注入样式，否则你应该使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 或者 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\"。\"]}]}],\"\\n\",[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 可以在布局副作用触发之前将元素插入到 DOM 中。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"useInsertionEffect(setup, dependencies?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"useinsertioneffect\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect(setup, dependencies?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 在任何可能需要读取布局的副作用启动之前插入样式：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useInsertionEffect } from 'react';\\r\\n\\r\\n// 在你的 CSS-in-JS 库中\\r\\nfunction useCSS(rule) {\\r\\n  useInsertionEffect(() => {\\r\\n    // ... 在此注入 <style> 标签 ...\\r\\n  });\\r\\n  return rule;\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请参考下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"setup\"}],\"：处理 Effect 的函数。setup 函数选择性返回一个 \",[\"$r\",\"strong\",null,{\"children\":\"清理（cleanup）\"}],\" 函数。当你的组件添加到 DOM 中，但在任何布局触发之前，React 将运行你的 setup 函数。在每次重新渲染时，如果依赖项发生变化并且提供了 cleanup 函数，React 首先会使用旧值运行 cleanup 函数，然后使用新值运行你的 setup 函数。当你的组件从 DOM 中移除时，React 将运行你的 cleanup 函数。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"dependencies\"}],\"：\",[\"$r\",\"code\",null,{\"children\":\"setup\"}],\" 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。如果你的代码检查工具 \",[\"$r\",\"a\",null,{\"href\":\"/learn/editor-setup#linting\",\"children\":\"配置了 React\"}],\"，那么它将验证是否每个响应式值都被正确地指定为依赖项。依赖列表必须具有固定数量的项，并且必须像 \",[\"$r\",\"code\",null,{\"children\":\"[dep1, dep2, dep3]\"}],\" 这样内联编写。React 将使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 来比较每个依赖项和它先前的值。如果省略此参数，则将在每次重新渲染组件之后重新运行 Effect。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 返回 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"。\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Effect 只在客户端运行。在服务器渲染期间不会运行。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你不能在 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 内部更新状态。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 运行时，\",[\"$r\",\"code\",null,{\"children\":\"refs\"}],\" 尚未附加。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 可能在 DOM 更新之前或之后运行。你不应该依赖于 DOM 在任何特定时间的更新状态。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"与其他类型的 Effect 不同，它们会先为每个 Effect 触发 cleanup 函数，然后再触发 setup 函数。而 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 会同时触发 cleanup 函数和 setup 函数。这会导致 cleanup 函数和 setup 函数的“交错”执行。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"injecting-dynamic-styles-from-css-in-js-libraries\",\"children\":\"从 CSS-in-JS 库中注入动态样式 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"传统上，你会使用纯 CSS 为 React 组件设置样式。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"// 在你的 JS 文件中：\\r\\n<button className=\\\"success\\\" />\\r\\n\\r\\n// 在你的 CSS 文件中：\\r\\n.success { color: green; }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有些团队更喜欢直接在 JavaScript 代码中编写样式，而不是编写 CSS 文件。这通常需要使用 CSS-in-JS 库或工具。以下是 CSS-in-JS 三种常见的实现方法：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"使用编译器静态提取到 CSS 文件\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"内联样式，例如 \",[\"$r\",\"code\",null,{\"children\":\"<div style={{ opacity: 1 }}>\"}]]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"运行时注入 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你使用 CSS-in-JS，我们建议结合使用前两种方法（静态样式使用 CSS 文件，动态样式使用内联样式）。\",[\"$r\",\"strong\",null,{\"children\":[\"我们不建议运行时注入 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签有两个原因\"]}],\"：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"运行时注入会使浏览器频繁地重新计算样式。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如果在 React 生命周期中某个错误的时机进行运行时注入，它可能会非常慢。\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"第一个问题无法解决，但是 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 可以帮助你解决第二个问题。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Call \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" to insert the styles before any layout Effects fire:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-11}\",\"children\":\"// 在你的 CSS-in-JS 库中\\r\\nlet isInserted = new Set();\\r\\nfunction useCSS(rule) {\\r\\n  useInsertionEffect(() => {\\r\\n    // 同前所述，我们不建议在运行时注入 <style> 标签。\\r\\n    // 如果你必须这样做，那么应当在 useInsertionEffect 中进行。\\r\\n    if (!isInserted.has(rule)) {\\r\\n      isInserted.add(rule);\\r\\n      document.head.appendChild(getStyleForRule(rule));\\r\\n    }\\r\\n  });\\r\\n  return rule;\\r\\n}\\r\\n\\r\\nfunction Button() {\\r\\n  const className = useCSS('...');\\r\\n  return <div className={className} />;\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"与 \",[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\" 类似，\",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 不在服务端运行。如果你需要收集在服务端上使用了哪些 CSS 规则，你可以在渲染期间进行：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4-6}\",\"children\":\"let collectedRulesSet = new Set();\\r\\n\\r\\nfunction useCSS(rule) {\\r\\n  if (typeof window === 'undefined') {\\r\\n    collectedRulesSet.add(rule);\\r\\n  }\\r\\n  useInsertionEffect(() => {\\r\\n    // ...\\r\\n  });\\r\\n  return rule;\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"https://github.com/reactwg/react-18/discussions/110\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"阅读更多使用 \",[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 升级 CSS-in-JS 库的相关指南\"]}],\"。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect\",\"children\":[\"这与在渲染期间或 \",[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}],\" 中注入样式相比有何优势？ \"]}],[\"$r\",\"p\",null,{\"children\":[\"如果你在渲染期间注入样式并且 React 正在处理 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition\",\"children\":\"非阻塞更新\"}],\"，那么浏览器将在渲染组件树时每一帧都会重新计算样式，这可能会 \",[\"$r\",\"strong\",null,{\"children\":\"非常慢\"}],\"。\"]}],[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useInsertionEffect\"}],\" 比在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useLayoutEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useLayoutEffect\"}]}],\" 或 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useEffect\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffect\"}]}],\" 期间注入样式更好。因为它会确保 \",[\"$r\",\"code\",null,{\"children\":\"<style>\"}],\" 标签在其它 Effect 运行前被注入。否则，正常的 Effect 中的布局计算将由于过时的样式而出错。\"]}]]}]]}]]","meta":{"title":"useInsertionEffect"},"languages":null},"__N_SSG":true}