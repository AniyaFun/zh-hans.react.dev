{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#only-call-hooks-at-the-top-level\",\"depth\":2,\"text\":\"只在顶层调用 Hook \"},{\"url\":\"#only-call-hooks-from-react-functions\",\"depth\":2,\"text\":\"仅在 React 函数中调用 Hook \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"Hook 是使用 JavaScript 函数定义的，但它们代表了一种特殊的可重用的 UI 逻辑，并且对它们可以被调用的位置有限制。\"}]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"only-call-hooks-at-the-top-level\",\"children\":\"只在顶层调用 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在 React 中，以 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 开头命名的函数被称为 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/reference/react\",\"children\":\"Hook\"}]}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"不要在循环、条件语句、嵌套函数或 \",[\"$r\",\"code\",null,{\"children\":\"try\"}],\"/\",[\"$r\",\"code\",null,{\"children\":\"catch\"}],\"/\",[\"$r\",\"code\",null,{\"children\":\"finally\"}],\" 代码块中调用 Hook\"]}],\"。相反，你应该在 React 函数组件的顶层使用 Hook，且在任何提前返回之前。你只能在 React 渲染函数组件时调用 Hook：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"✅ 在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/your-first-component\",\"children\":\"函数组件主体\"}],\" 的顶层调用它们。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"✅ 在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks\",\"children\":\"自定义 Hook 主体\"}],\" 的顶层调用它们。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js{2-3,8-9}\",\"children\":\"function Counter() {\\r\\n  // ✅ 正确的：在函数组件顶层\\r\\n  const [count, setCount] = useState(0);\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction useWindowWidth() {\\r\\n  // ✅ 正确的：在自定义 Hooks 顶层\\r\\n  const [width, setWidth] = useState(window.innerWidth);\\r\\n  // ...\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"不支持在其他任何情况下调用以 \",[\"$r\",\"code\",null,{\"children\":\"use\"}],\" 开头的 Hook，例如：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"🔴 不要在条件语句或循环中调用 Hook。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"🔴 不要在条件性的 \",[\"$r\",\"code\",null,{\"children\":\"return\"}],\" 语句之后调用 Hook。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"🔴 不要在事件处理函数中调用 Hook。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"🔴 不要在类组件中调用 Hook。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"🔴 不要在传递给 \",[\"$r\",\"code\",null,{\"children\":\"useMemo\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"useEffect\"}],\" 的函数内部调用 Hook。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"🔴 不要在 \",[\"$r\",\"code\",null,{\"children\":\"try\"}],\"/\",[\"$r\",\"code\",null,{\"children\":\"catch\"}],\"/\",[\"$r\",\"code\",null,{\"children\":\"finally\"}],\" 代码块中调用 Hook。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你违反了这些规则，你可能会看到以下错误：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js{3-4,11-12,20-21}\",\"children\":\"function Bad({ cond }) {\\r\\n  if (cond) {\\r\\n    // 🔴 错误的：在条件语句内部（要修复这个问题，将其移到外部！）\\r\\n    const theme = useContext(ThemeContext);\\r\\n  }\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction Bad() {\\r\\n  for (let i = 0; i < 10; i++) {\\r\\n    // 🔴 错误的：在循环语句内部（要修复这个问题，将其移到外部！）\\r\\n    const theme = useContext(ThemeContext);\\r\\n  }\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction Bad({ cond }) {\\r\\n  if (cond) {\\r\\n    return;\\r\\n  }\\r\\n  // 🔴 错误的：在条件性 return 语句之后（要修复这个问题，将其移到 return 之前！）\\r\\n  const theme = useContext(ThemeContext);\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction Bad() {\\r\\n  function handleClick() {\\r\\n    // 🔴 错误的：在事件处理函数内部（要修复这个问题，将其移到 return 之前！）\\r\\n    const theme = useContext(ThemeContext);\\r\\n  }\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction Bad() {\\r\\n  const style = useMemo(() => {\\r\\n    // 🔴 错误的：在 useMemo 内部调用（要修复这个问题，将其移到外部！）\\r\\n    const theme = useContext(ThemeContext);\\r\\n    return createStyle(theme);\\r\\n  });\\r\\n  // ...\\r\\n}\\r\\n\\r\\nclass Bad extends React.Component {\\r\\n  render() {\\r\\n    // 🔴 错误的：在类组件内部调用（要修复这个问题，改写为函数组件！）\\r\\n    useEffect(() => {})\\r\\n    // ...\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction Bad() {\\r\\n  try {\\r\\n    // 🔴 错误的：在 try、catch、finally 代码块内部调用（要修复这个问题，将其移到外部！）\\r\\n    const [x, setX] = useState(0);\\r\\n  } catch {\\r\\n    const [x, setX] = useState(1);\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://www.npmjs.com/package/eslint-plugin-react-hooks\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"eslint-plugin-react-hooks\"}],\" 插件\"]}],\" 来捕获这些错误。\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks\",\"children\":\"自定义 Hook\"}],\" \",[\"$r\",\"strong\",null,{\"children\":\"可以\"}],\" 调用其他 Hook（这正是它们的主要目的）。之所以可以这样做，是因为自定义 Hook 也应该只在函数组件渲染时被调用。\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"only-call-hooks-from-react-functions\",\"children\":\"仅在 React 函数中调用 Hook \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"不要在常规的 JavaScript 函数中调用 Hook。相反，你可以：\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"✅ 在 React 函数组件中调用 Hook。\\r\\n✅ 在 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component\",\"children\":\"自定义 Hook\"}],\" 中调用 Hook。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"遵循这条规则，你可以确保组件中的所有状态逻辑在其源代码中清晰可见。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,5}\",\"children\":\"function FriendList() {\\r\\n  const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ✅\\r\\n}\\r\\n\\r\\nfunction setOnlineStatus() { // ❌ Not a component or custom Hook!\\r\\n  const [onlineStatus, setOnlineStatus] = useOnlineStatus();\\r\\n}\\n\"}]}]]}]]","meta":{"title":"Hook 的规则"},"languages":null},"__N_SSG":true}